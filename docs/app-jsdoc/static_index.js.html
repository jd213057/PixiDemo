<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: static/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: static/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import loaders from './loaders.js';
import colliders from './colliders.js';
/**
 * @type {HTMLAudioElement}
 */
const attackSound = new Audio(
	'static/assets/audio/sounds/street-fighter-sound-hadouken.mp3'
);
/**
 * @type {HTMLAudioElement}
 */
const walkingSound = new Audio('static/assets/audio/sounds/step_lth4.mp3');
/**
 * @type {number}
 */
let animationCount = 0;
/**
 * @type {number}
 */
let direction = 1;
/**
 * @type {boolean}
 */
let isJumping = false;
/**
 * @type {boolean}
 */
let onFloor = false;
/**
 * @type {boolean}
 */
let isAboutToCollide = false;
/**
 * @type {Array}
 */
let wallCollidersList = [];
/**
 * @type {Array}
 */
let floorCollidersList = [];
/**
 * @type {PIXI.Rectangle}
 */
let warriorNarrowBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 */
let bottomCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 */
let leftCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 */
let rightCollisionBox = new PIXI.Rectangle();
/**
 * @type {number}
 */
let vx = 0;
/**
 * @type {number}
 */
let vy = 5;

setControls();
setKeyboardControls();
setBackgroundVolume();
setAudioEvents();

const app = new PIXI.Application({
	height: 550,
	width: 900,
	transparent: true,
});

document.getElementById('screen').appendChild(app.view);

const pathToImgFolder = '/static/assets/images/';
let backgroundImage = PIXI.Texture.from(
	pathToImgFolder + 'Levels/firstmaplevel_background.png'
);
let backgroundSprite = new PIXI.Sprite(backgroundImage);
backgroundSprite.anchor.set(0.0);
backgroundSprite.height = 642;
backgroundSprite.width = 3073;
app.stage.addChild(backgroundSprite);

setColliders(colliders);

// path starting point from server.js where script js is served
/**
 * @type {string}
 */
const pathToAnimation = '/static/assets/images/';

let textureArray = [];
let texture = PIXI.Texture.from(
	pathToAnimation + 'Adventurer/Idle/adventurer-idle-00.png'
);
textureArray.push(texture);
let warrior = new PIXI.AnimatedSprite(textureArray);

loadIdleTexture();
// center the sprite's anchor point
warrior.anchor.set(0.5);

// move the sprite to the center of the screen

warrior.scale.x = 2;
warrior.scale.y = 2;
warrior.x = app.screen.width / 2 - 350;
warrior.y = app.screen.height / 2 - 150;
app.stage.addChild(warrior);

// Listen for animate update
app.ticker.add((delta) => {
	warriorNarrowBox = warrior.getBounds();
	calculateWideBoxes();
	isAboutToCollide = detectFloorCollision(bottomCollisionBox);
	if (!isAboutToCollide) {
		applyingGravity();
	}
	if (isJumping) {
		makeJump();
	}
	const animationSpeed = delta / 4;
	animationCount =
		Math.round(animationCount + animationSpeed) % textureArray.length;
	warrior.texture = textureArray[animationCount];
});

var playingSound = false;

// Build Map functions

function setColliders(collidersConf) {
	let floorCollidersObject = collidersConf.floorColliders;
	let wallCollidersObject = collidersConf.wallColliders;
	let collider;
	for (const floorConf in floorCollidersObject) {
		collider = createBasicCollider(floorCollidersObject[floorConf]);
		app.stage.addChild(collider);
		floorCollidersList.push(collider.getBounds());
	}
	for (const wallConf in wallCollidersObject) {
		collider = createBasicCollider(wallCollidersObject[wallConf]);
		app.stage.addChild(collider);
		wallCollidersList.push(collider);
	}
}

function createBasicCollider(colliderConf) {
	let newTexture = PIXI.Texture.from(colliderConf.imgPath);
	let newCollider = new PIXI.Sprite(newTexture);
	newCollider.anchor.set(colliderConf.anchor);
	newCollider.x = colliderConf.x;
	newCollider.y = colliderConf.y;
	newCollider.width = colliderConf.width;
	newCollider.height = colliderConf.height;
	return newCollider;
}

// Controls functions :

function setControls() {
	document.getElementById('Attack').addEventListener('click', () => {
		loadSmallAttackTexture();
	});
	document.getElementById('Attack2').addEventListener('click', () => {
		loadBigAttackTexture();
	});
	document.getElementById('Idle').addEventListener('click', () => {
		loadIdleTexture();
	});
	document.getElementById('Jump').addEventListener('click', () => {
		loadJumpTexture();
	});
	document.getElementById('Die').addEventListener('click', () => {
		loadDieTexture();
	});
	document.getElementById('Run').addEventListener('click', () => {
		loadRunTexture();
	});
}

function setKeyboardControls() {
	window.addEventListener(
		'keydown',
		(e) => {
			if (e.defaultPrevented) {
				return; // Ne devrait rien faire si l'événement de la touche était déjà consommé.
			}

			switch (e.key) {
				case 'ArrowDown':
					crouch();
					break;
				case 'ArrowUp':
					jump();
					break;
				case 'ArrowLeft':
					warrior.scale.x = -2;
					direction = -1;
					if (!detectWallCollision(leftCollisionBox)) {
						move();
					}
					break;
				case 'ArrowRight':
					warrior.scale.x = 2;
					direction = 1;
					warrior.y -= 5;
					if (!detectWallCollision(rightCollisionBox)) {
						move();
					}
					break;
				case 'é':
					takePotion();
					break;
				case 'a':
					smallAttack();
					break;
				case 'z':
					bigAttack();
					break;
				default:
					return; 
			}
			e.preventDefault();
		},
		true
	);

	window.addEventListener('keyup', (e) => {
		stop();
	});
}

// Move functions :

function calculateWideBoxes() {
	bottomCollisionBox.x =
		warriorNarrowBox.x + (1 / 3) * warriorNarrowBox.width;
	bottomCollisionBox.width = (1 / 3) * warriorNarrowBox.width;
	bottomCollisionBox.y =
		warriorNarrowBox.y + (2 / 3) * warriorNarrowBox.height;
	bottomCollisionBox.height = (1 / 3) * warriorNarrowBox.height + 1;
	leftCollisionBox.x = warriorNarrowBox.x + 10;
	leftCollisionBox.width = warriorNarrowBox.width / 2 - 15;
	leftCollisionBox.y = warriorNarrowBox.y - 1;
	leftCollisionBox.height = warriorNarrowBox.height + 1;
	rightCollisionBox.x = warriorNarrowBox.x + warriorNarrowBox.width / 2;
	rightCollisionBox.width = warriorNarrowBox.width / 2 - 15;
	rightCollisionBox.y = warriorNarrowBox.y - 1;
	rightCollisionBox.height = warriorNarrowBox.height + 1;
}

function move() {
	if (!isJumping &amp;&amp; onFloor) {
		playSound(walkingSound);
		loadRunTexture();
		vx = 5;
		warrior.x += vx * direction;
	}
}

function jump() {
	loadJumpTexture();
	if (!isJumping &amp;&amp; onFloor) {
		isJumping = true;
		onFloor = false;
		makeJump();
		setTimeout(() => {
			isJumping = false;
		}, 750);
	}
}

function stop() {
	if (!isJumping &amp;&amp; onFloor) {
		loadIdleTexture();
	}
	playingSound = false;
	setTimeout(() => {
		vx = 0;
	}, 250);
	vx = 0;
	stopSound();
}

function smallAttack() {
	playSound(attackSound);
	loadSmallAttackTexture();
}

function bigAttack() {
	playSound(attackSound);
	loadBigAttackTexture();
}

function crouch() {
	loadCrouchTexture();
}

function takePotion() {
	loadTakePotionTexture();
}

// Physics functions:

function detectWallCollision(playerBox) {
	for (const collider of wallCollidersList) {
		if (
			playerBox.x + playerBox.width > collider.x &amp;&amp;
			playerBox.x &lt; collider.x + collider.width &amp;&amp;
			playerBox.y + playerBox.height > collider.y &amp;&amp;
			playerBox.y &lt; collider.y + collider.height
		) {
			return true;
		}
	}
	return false;
}

function detectFloorCollision(playerBox) {
	for (const collider of floorCollidersList) {
		if (
			playerBox.x + playerBox.width > collider.x &amp;&amp;
			playerBox.x &lt; collider.x + collider.width &amp;&amp;
			playerBox.y + playerBox.height > collider.y &amp;&amp;
			playerBox.y &lt; collider.y + collider.height
		) {
			isJumping = false;
			onFloor = true;
			return true;
		}
	}
	return false;
}

function applyingGravity() {
	warrior.y += vy;
}

function makeJump() {
	vx -= 0.1 * direction;
	warrior.x += vx;
	warrior.y -= vy + 5;
}

//Audio functions:

function setBackgroundVolume() {
	const backgroundAudio = document.getElementById('audio');
	backgroundAudio.volume = 0.3;
}

function playSound(sound) {
	if (!playingSound) {
		sound.currentTime = 0;
		sound.volume = 1;
		sound.play();
	}
	playingSound = true;
}

function stopSound() {
	attackSound.pause();
	walkingSound.pause();
}

function setAudioEvents() {
	attackSound.addEventListener('play', () => {
		attackSound.volume = 0.5;
	});
	attackSound.addEventListener('ended', () => {
		playingSound = false;
	});
	walkingSound.addEventListener('ended', () => {
		playingSound = false;
	});
}

// TextureLoader functions :

function loadSmallAttackTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerAttacking1Anim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadBigAttackTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerAttacking2Anim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadIdleTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerIdlingAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadJumpTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerJumpingAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadRunTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerRunningAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadDieTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerDyingAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadCrouchTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerCrouchingAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}

function loadTakePotionTexture() {
	textureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerTakingPotionAnim;
	loaderArray.forEach((img) => textureArray.push(new PIXI.Texture.from(img)));
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#animationCount">animationCount</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#attackSound">attackSound</a></li><li><a href="global.html#bottomCollisionBox">bottomCollisionBox</a></li><li><a href="global.html#connectLivereload">connectLivereload</a></li><li><a href="global.html#direction">direction</a></li><li><a href="global.html#dirUrl">dirUrl</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#floorColliders">floorColliders</a></li><li><a href="global.html#floorCollidersList">floorCollidersList</a></li><li><a href="global.html#isAboutToCollide">isAboutToCollide</a></li><li><a href="global.html#isJumping">isJumping</a></li><li><a href="global.html#leftCollisionBox">leftCollisionBox</a></li><li><a href="global.html#livereload">livereload</a></li><li><a href="global.html#liveReloadServer">liveReloadServer</a></li><li><a href="global.html#loaders">loaders</a></li><li><a href="global.html#onFloor">onFloor</a></li><li><a href="global.html#opn">opn</a></li><li><a href="global.html#pathToAnimation">pathToAnimation</a></li><li><a href="global.html#pathToImgFolder">pathToImgFolder</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#rightCollisionBox">rightCollisionBox</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#vx">vx</a></li><li><a href="global.html#vy">vy</a></li><li><a href="global.html#walkingSound">walkingSound</a></li><li><a href="global.html#wallColliders">wallColliders</a></li><li><a href="global.html#wallCollidersList">wallCollidersList</a></li><li><a href="global.html#warriorNarrowBox">warriorNarrowBox</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Oct 30 2020 18:48:51 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
