<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: static/index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: static/index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import loaders from './loaders.js';
import spritesConfig from './sprites.js';
import textConfig from './text.js';
import GAME_SETTINGS from './settings.js';
import PIXI from './pixi-legacy.js';
/**
 * @type {HTMLAudioElement}
 * @description Path of sound file played when attacking
 */
const attackSound = new Audio(
	'static/assets/audio/sounds/street-fighter-sound-hadouken.mp3'
);
/**
 * @type {HTMLAudioElement}
 * @description Path of sound file played when walking
 */
const walkSound = new Audio('static/assets/audio/sounds/step_lth4.mp3');
/**
 * @type {HTMLAudioElement}
 * @description Path of sound file when played jumping
 */
const warriorJumpSound = new Audio(
	'static/assets/audio/sounds/warriorJumpSound.mp3'
);
/**
 * @type {HTMLAudioElement}
 * @description Path of sound file when opening treasure chest
 */
const openingTreasureChestSound = new Audio(
	'static/assets/audio/sounds/treasure-chest-opening.mp3'
);
/**
 * @type {number}
 * @description Index of Adventurer's array texture synchronized with delta
 */
let adventurerAnimationCount = 0;
/**
 * @type {number}
 * @description Index of Treasure Chest's array texture synchronized with delta
 */
let treasureChestAnimationCount = 0;
/**
 * @type {number}
 * @description Index of textList array
 */
let indexOfTextList = 0;
/**
 * @type {number}
 * @description Determines whether player goes forward or backward
 */
let direction = 1;
/**
 * @type {boolean}
 * @description Indicates whether text content is been displayed or not
 */
let displayingText = false;
/**
 * @type {boolean}
 * @description Indicates whether warning text content is been displayed or not
 */
let displayingWarningText = false;
/**
 * @type {boolean}
 * @description Indicates whether text content for first area of level has been displayed
 */
let hasBeenDisplayedZone1;
/**
 * @type {boolean}
 * @description Indicates whether text content for second area of level has been displayed
 */
let hasBeenDisplayedZone2;
/**
 * @type {boolean}
 * @description Indicates whether text content for third area of level has been displayed
 */
let hasBeenDisplayedZone3;
/**
 * @type {boolean}
 * @description Indicates whether player is jumping or not
 */
let isJumping = false;
/**
 * @type {boolean}
 * @description Bottom part of player's sprite used for floor collisions
 */
let isAboutToCollideWithBottom = false;
/**
 * @type {boolean}
 * @description Top part of player's sprite used for floor collisions
 */
let isAboutToCollideWithTop = false;
/**
 * @type {boolean}
 * @description Left part of player's sprite used for wall collisions
 */
let isAboutToCollideWithLeft = false;
/**
 * @type {boolean}
 * @description Right part of player's sprite used for wall collisions
 */
let isAboutToCollideWithRight = false;
/**
 * @type {boolean}
 * @description Indicates whether first treasure chest is opened or not
 */
let treasureChestOpened1 = false;
/**
 * @type {boolean}
 * @description Indicates whether second treasure chest is opened or not
 */
let treasureChestOpened2 = false;
/**
 * @type {boolean}
 * @description Indicates whether third treasure chest is opened or not
 */
let treasureChestOpened3 = false;
/**
 * @type {boolean}
 * @description Indicates whether player is left centered on the screen
 */
let isWarriorLeftCentered = false;
/**
 * @type {boolean}
 * @description Indicates whether player is right centered on the screen
 */
let isWarriorRightCentered = false;
/**
 * @type {boolean}
 * @description Indicates if left edge of screen is reached by player or not
 */
let leftEdgeScreenReached = false;
/**
 * @type {boolean}
 * @description Indicates if left edge of screen is reached by player or not
 */
let rightEdgeScreenReached = false;
/**
 * @type {boolean}
 * @description Indicates if left part of stage is reached or not
 */
let leftEdgeStageReached = false;
/**
 * @type {boolean}
 * @description Indicates if right part of stage is reached or not
 */
let rightEdgeStageReached = false;
/**
 * @type {Array}
 * @description ArrayList of all colliders
 */
let collidersCheckList = [];
/**
 * @type {Array}
 * @description ArrayList of floor colliders
 */
let obstacleCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of object colliders
 */
let objectCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of scenery colliders
 */
let decorsCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of mobile colliders moving from left to right
 */
let leftToRightCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of mobile colliders moving from right to left
 */
let rightToLeftCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of mobile colliders moving from bottom to top
 */
let bottomToTopCollidersList = [];
/**
 * @type {Array}
 * @description ArrayList of mobile colliders moving from top to bottom
 */
let topToBottomCollidersList = [];
/**
 * @type {PIXI.Sprite}
 * @description Treasure Chest sprite
 */
let treasureChest1 = false;
/**
 * @type {Array}
 * @description ArrayList of Treasure Chest's textures used for current animation
 */
let treasureChest1TextureArray = [];
/**
 * @type {PIXI.Sprite}
 * @description Treasure Chest sprite
 */
let treasureChest2 = false;
/**
 * @type {Array}
 * @description ArrayList of Treasure Chest's textures used for current animation
 */
let treasureChest2TextureArray = [];
/**
 * @type {PIXI.Sprite}
 * @description Treasure Chest sprite
 */
let treasureChest3 = false;
/**
 * @type {Array}
 * @description ArrayList of Treasure Chest's textures used for current animation
 */
let treasureChest3TextureArray = [];
/**
 * @type {Array}
 * @description ArrayList of text content used for the game
 */
let textListToShow = [];
/**
 * @type {PIXI.Rectangle}
 * @description Player bounds
 */
let warriorBounds = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 * @description Player's bottom part bounds
 */
let bottomCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 * @description Player's top part bounds
 */
let topCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 * @description Player's left part bounds
 */
let leftCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 * @description Player's right part bounds
 */
let rightCollisionBox = new PIXI.Rectangle();
/**
 * @type {PIXI.Rectangle}
 * @description Updated left screen limit player cannot pass
 */
let updatedLeftEdgeScreen;
/**
 * @type {PIXI.Rectangle}
 * @description Updated right screen limit player cannot pass
 */
let updatedRightEdgeScreen;
/**
 * @type {number}
 * @description Player's speed for x abscissa
 */
let vx = GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED;
/**
 * @type {number}
 * @description Player's speed for y abscissa
 */
let vy = GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED;
/**
 * @type {PIXI.Texture}
 * @description Background texture for textBox
 */
let textBackGroundTexture = new PIXI.Sprite(PIXI.Texture.WHITE);
/**
 * @type {PIXI.Texture}
 * @description Background texture for warningTextBox
 */
let warningTextBackGroundTexture = new PIXI.Sprite(PIXI.Texture.WHITE);
/**
 * @type {PIXI.Text}
 * @description Container for text display
 */
let text = new PIXI.Text();
/**
 * @type {PIXI.Text}
 * @description Container for warning text display
 */
let warningText = new PIXI.Text();
/**
 * @type {PIXI.Sprite}
 * @description Next text button icon for warningTextBox
 */
let warningNextTextButtonImg = new PIXI.Sprite();
/**
 * @type {PIXI.Container}
 * @description Container for text display
 */
let textBox = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Container for warning text display
 */
let warningTextBox = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Container for all foreground stage elements
 */
let foreground = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Container for all middleground stage elements
 */
let middleground = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Container for all backgorund stage elements
 */
let background = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of Foreground, contains all moving colliders
 */
let foregroundStaticCollidersSubContainer = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of Foreground, contains all moving colliders
 */
let foregroundMobileCollidersSubContainer = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of foregroundMobileCollidersSubContainer, contains all moving colliders from left to right
 */
let leftToRightForegroundSubContainer = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of foregroundMobileCollidersSubContainer, contains all moving colliders from right to left
 */
let rightToLeftForegroundSubContainer = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of foregroundMobileCollidersSubContainer, contains all moving colliders from top to bottom
 */
let topToBottomForegroundSubContainer = new PIXI.Container();
/**
 * @type {PIXI.Container}
 * @description Child container of foregroundMobileCollidersSubContainer, contains all moving colliders from bottom to top
 */
let bottomToTopForegroundSubContainer = new PIXI.Container();
/**
 * @type {NodeJS.Timeout}
 * @description Timer for vx decreasing when player stops
 */
let vxTimer;
/**
 * @type {number}
 * @description Counter for mobile platforms
 */
let movementCount = 0;
/**
 * @type {number}
 * @description Speed for mobile platforms
 */
let movementSpeed = GAME_SETTINGS.PHYSICS_SETTINGS.MOBILE_COLLIDERS_SPEED;
/**
 * @type {boolean}
 * @description Indicates whether sound is playing or not
 */
let playingSound = false;
/**
 * @type {Object}
 * @description Enumeration of all text display zone
 */
const textDisplayZoneEnum = {
	ZONE_ONE: 'zoneOne',
	ZONE_TWO: 'zoneTwo',
	ZONE_THREE: 'zoneThree',
	NO_ZONE: 'noZone',
};
/**
 * @type {Object}
 * @description Indicates whether warrior is in a text display zone or not
 */
let textDisplayZone = textDisplayZoneEnum.NO_ZONE;
/**
 * @type {Object}
 * @description Enumeration of all possible player's animation state
 */
const animationStateEnum = {
	ATTACKING_ONE: 'attackingOne',
	ATTACKING_TWO: 'attackingTwo',
	JUMPING: 'jumping',
	IDLING: 'idling',
	RUNNING: 'running',
	CROUCHING: 'crouching',
	TAKING_POTION: 'takingPotion',
};
/**
 * @type {Object}
 * @description Player's animation state
 */
let animationState = animationStateEnum.IDLING;
/**
 * @type {PIXI.AnimatedSprite}
 * @description Player's sprite
 */
let warrior;
/**
 * @type {PIXI.Application}
 * @description Pixi application embedded in index.html's screen
 */
var app = new PIXI.Application({
	width: GAME_SETTINGS.APP_SCREEN_SETTINGS.APP_SCREEN_WIDTH,
	height: GAME_SETTINGS.APP_SCREEN_SETTINGS.APP_SCREEN_HEIGHT,
	transparent: GAME_SETTINGS.APP_SCREEN_SETTINGS.TRANSPARENT,
	antialias: GAME_SETTINGS.APP_SCREEN_SETTINGS.ANTIALIASING,
	x: GAME_SETTINGS.APP_SCREEN_SETTINGS.APP_SCREEN_X,
	y: GAME_SETTINGS.APP_SCREEN_SETTINGS.APP_SCREEN_Y,
});
/**
 * @type {Array}
 * @description ArrayList of player's textures used for cureent animation
 */
let warriorTextureArray = [];
/**
 * @type {string}
 * @description Path to image repository
 */
const pathToAnimation = '/static/assets/images/';
/**
 * @type {number}
 * @description Time in ms since last frame was rendered
 */
let elapsedTime = 0;
/**
 * @type {number}
 * @description Delay in ms targeted between last frame and current frame displayed
 */
const fpsDelta = GAME_SETTINGS.TICKER_SETTINGS.DELTA_TIME_TARGETED;

// Initialization IIFE function

(function initializeGame() {
	removeDefaultTicker();
	setControls();
	setKeyboardControls();
	setBackgroundVolume();
	setAudioEvents();
	addStageToScreen();
	buildStage();
	getInitialEdgeScreen();
	setTicker();
})();

//Core functions called to initialize or update game rendering

function removeDefaultTicker() {
	app.ticker.remove(app.render, app);
}

function tick(delta) {
	elapsedTime += delta;
	if (elapsedTime >= fpsDelta) {
		update(elapsedTime);
		elapsedTime = 0;
	}
}

function update(delta) {
	reloadIfFalling();
	calculateWideBoxes();
	updateCameraCheckers();
	updateMovementCycle();
	updateMobileColliders();
	updateAllCollidersList();
	updateWarriorCollider();
	updatingVx();
	if (isAboutToCollideWithBottom || isAboutToCollideWithTop) {
		vy = isAboutToCollideWithBottom
			? GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED
			: vy &lt;= GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED
			? GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_RESTITUTION_COEF * vy
			: vy;
		isJumping = isAboutToCollideWithBottom ? false : true;
	}
	updatingVy();
	moveCamera();
	updateAnimationState();
	loadWarriorAnimation();
	animateElements(delta);
	manageTextContent(warrior.x);
	render();
}

function render() {
	app.render();
}

// Build Stage functions

function buildStage() {
	setBackgroungImg();
	setBackground();
	setMiddleGroundImg();
	setMiddleground();
	setDecors();
	setStaticColliders();
	setObjects();
	setMobileColliders();
	setForeground();
	addWarriorToStage();
}

function setBackgroungImg() {
	let backgroundImage = PIXI.Texture.from(
		pathToAnimation + 'Levels/firstmaplevel_background.png'
	);
	let backgroundSprite1 = new PIXI.Sprite(backgroundImage);
	backgroundSprite1.anchor.set(0.0);
	backgroundSprite1.x = 0;
	backgroundSprite1.y = 0;
	backgroundSprite1.height = 642;
	backgroundSprite1.width = 3073;
	background.addChild(backgroundSprite1);
	let backgroundSprite2 = new PIXI.Sprite(backgroundImage);
	backgroundSprite2.anchor.set(0.0);
	backgroundSprite2.x = 3072;
	backgroundSprite2.y = 0;
	backgroundSprite2.height = 642;
	backgroundSprite2.width = 3073;
	background.addChild(backgroundSprite2);
}

function setBackground() {
	app.stage.addChild(background);
}

function setMiddleGroundImg() {
	let middlegroundImage = PIXI.Texture.from(
		pathToAnimation + 'Levels/middleground_level_01.png'
	);
	let middlegroundSprite1 = new PIXI.Sprite(middlegroundImage);
	middlegroundSprite1.anchor.set(0.0);
	middlegroundSprite1.x = 0;
	middlegroundSprite1.y = 0;
	middlegroundSprite1.height = 642;
	middlegroundSprite1.width = 3073;
	middleground.addChild(middlegroundSprite1);
	let middlegroundSprite2 = new PIXI.Sprite(middlegroundImage);
	middlegroundSprite2.anchor.set(0.0);
	middlegroundSprite2.x = 3072;
	middlegroundSprite2.y = 0;
	middlegroundSprite2.height = 642;
	middlegroundSprite2.width = 3073;
	middleground.addChild(middlegroundSprite2);
}

function setMiddleground() {
	app.stage.addChild(middleground);
}

function setForeground() {
	app.stage.addChild(foreground);
}

function setDecors() {
	let decorsCollidersObject = spritesConfig.decorsColliders;
	let collider;
	for (const decorsConf in decorsCollidersObject) {
		collider = createBasicCollider(decorsCollidersObject[decorsConf]);
		foreground.addChild(collider);
		decorsCollidersList.push(collider.getBounds());
	}
}

function setObjects() {
	treasureChest1 = createBasicSprite(
		treasureChest1TextureArray,
		treasureChest1,
		spritesConfig.objectColliders.treasureChest1
	);
	treasureChest2 = createBasicSprite(
		treasureChest2TextureArray,
		treasureChest2,
		spritesConfig.objectColliders.treasureChest2
	);
	treasureChest3 = createBasicSprite(
		treasureChest3TextureArray,
		treasureChest3,
		spritesConfig.objectColliders.treasureChest3
	);
	foreground.addChild(treasureChest1, treasureChest2, treasureChest3);
	objectCollidersList.push(treasureChest1, treasureChest2, treasureChest3);
}

function addWarriorToStage() {
	warrior = createBasicSprite(
		warriorTextureArray,
		warrior,
		spritesConfig.warriorColliders.warriorCollider1
	);
	loadIdleTexture();
	foreground.addChild(warrior);
}

function addStageToScreen() {
	document.getElementById('screen').appendChild(app.view);
}

function getInitialEdgeScreen() {
	updatedLeftEdgeScreen = app.screen.x;
	updatedRightEdgeScreen = app.screen.width;
}

function setTicker() {
	app.ticker.maxFPS = GAME_SETTINGS.TICKER_SETTINGS.TICKER_MAX_FPS;
	app.ticker.add(tick);
}

function setStaticColliders() {
	let obstacleCollidersObject = spritesConfig.obstacleColliders;
	let collider;
	for (const floorConf in obstacleCollidersObject) {
		collider = createBasicCollider(obstacleCollidersObject[floorConf]);
		foreground.addChild(collider);
		obstacleCollidersList.push(collider.getBounds());
	}
}

function setMobileColliders() {
	let collider;
	let mobileCollidersObject = spritesConfig.mobileColliders;
	for (const mobileCollider in mobileCollidersObject) {
		collider = createBasicCollider(mobileCollidersObject[mobileCollider]);
		switch (mobileCollidersObject[mobileCollider].movement) {
			case '+1X':
				setLeftToRightMobileSubContainer(collider);
				break;
			case '-1X':
				setRightToLeftMobileSubContainer(collider);
				break;
			case '+1Y':
				setTopToBottomMobileContainer(collider);
				break;
			case '-1Y':
				setBottomToTopMobileSubContainer(collider);
				break;
		}
	}
	foregroundMobileCollidersSubContainer.addChild(
		leftToRightForegroundSubContainer,
		rightToLeftForegroundSubContainer,
		topToBottomForegroundSubContainer,
		bottomToTopForegroundSubContainer
	);
	foreground.addChild(foregroundMobileCollidersSubContainer);
}

function setLeftToRightMobileSubContainer(collider) {
	leftToRightForegroundSubContainer.addChild(collider);
	leftToRightCollidersList.push(collider);
}

function setRightToLeftMobileSubContainer(collider) {
	rightToLeftForegroundSubContainer.addChild(collider);
	rightToLeftCollidersList.push(collider);
}

function setTopToBottomMobileContainer(collider) {
	topToBottomForegroundSubContainer.addChild(collider);
	topToBottomCollidersList.push(collider);
}

function setBottomToTopMobileSubContainer(collider) {
	bottomToTopForegroundSubContainer.addChild(collider);
	bottomToTopCollidersList.push(collider);
}

function createBasicSprite(
	spriteTextureArray,
	spriteObjectToInitialize,
	spriteConf
) {
	let texture = spriteConf.imgPath
		? PIXI.Texture.from(spriteConf.imgPath)
		: PIXI.Texture.WHITE;
	if (spriteTextureArray) {
		spriteTextureArray.push(texture);
	}
	spriteObjectToInitialize = new PIXI.Sprite(texture);
	spriteObjectToInitialize.anchor.set(spriteConf.anchor);
	spriteObjectToInitialize.x = spriteConf.x;
	spriteObjectToInitialize.y = spriteConf.y;
	spriteObjectToInitialize.width = spriteConf.width;
	spriteObjectToInitialize.height = spriteConf.height;
	if (spriteConf.tint) spriteObjectToInitialize.tint = spriteConf.tint;
	return spriteObjectToInitialize;
}

function createBasicCollider(colliderConf) {
	let newTexture = PIXI.Texture.from(colliderConf.imgPath);
	let newCollider = new PIXI.Sprite(newTexture);
	newCollider.anchor.set(colliderConf.anchor);
	newCollider.x = colliderConf.x;
	newCollider.y = colliderConf.y;
	newCollider.width = colliderConf.width;
	newCollider.height = colliderConf.height;
	return newCollider;
}

function updateMovementCycle() {
	const mobileCollidersCheckList = [
		leftToRightCollidersList,
		rightToLeftCollidersList,
		topToBottomCollidersList,
		bottomToTopCollidersList,
	];
	movementCount++;
	if (
		movementCount %
			GAME_SETTINGS.PHYSICS_SETTINGS.MOBILE_COLLIDERS_INVERSION ===
		0
	) {
		movementSpeed *= -1;
	}
	leftToRightForegroundSubContainer.x += movementSpeed;
	rightToLeftForegroundSubContainer.x -= movementSpeed;
	topToBottomForegroundSubContainer.y += movementSpeed;
	bottomToTopForegroundSubContainer.y -= movementSpeed;
	if (detectSpriteCollision(bottomCollisionBox, mobileCollidersCheckList)) {
		updateWarriorPositionOnMobileCollider(mobileCollidersCheckList);
	}
}

function updateWarriorPositionOnMobileCollider(mobileCollidersCheckList) {
	const idMobileCollidersSubList = getMobileColliderUnderWarrior(
		bottomCollisionBox,
		mobileCollidersCheckList
	);
	switch (idMobileCollidersSubList) {
		case 0:
			warrior.x += movementSpeed;
			break;
		case 1:
			warrior.x -= movementSpeed;
			break;
		case 2:
			warrior.y += movementSpeed;
			break;
		case 3:
			warrior.y -= movementSpeed;
			break;
	}
}

function updateMobileColliders() {
	// index = length - 2 car dernier élément ajouté à foreground correspond à warrior
	const mobileCollidersContainersList = Array.from(
		foreground.children[foreground.children.length - 2].children
	);
	leftToRightCollidersList = [];
	rightToLeftCollidersList = [];
	topToBottomCollidersList = [];
	bottomToTopCollidersList = [];
	if (
		mobileCollidersContainersList[0] !== undefined ||
		mobileCollidersContainersList !== null
	) {
		for (const mobileCollider of mobileCollidersContainersList[0]
			.children) {
			leftToRightCollidersList.push(mobileCollider.getBounds());
		}
	}
	if (
		mobileCollidersContainersList[1] !== undefined ||
		mobileCollidersContainersList !== null
	) {
		for (const mobileCollider of mobileCollidersContainersList[1]
			.children) {
			rightToLeftCollidersList.push(mobileCollider.getBounds());
		}
	}
	if (
		mobileCollidersContainersList[2] !== undefined ||
		mobileCollidersContainersList !== null
	) {
		for (const mobileCollider of mobileCollidersContainersList[2]
			.children) {
			topToBottomCollidersList.push(mobileCollider.getBounds());
		}
	}
	if (
		mobileCollidersContainersList[3] !== undefined ||
		mobileCollidersContainersList !== null
	) {
		for (const mobileCollider of mobileCollidersContainersList[3]
			.children) {
			bottomToTopCollidersList.push(mobileCollider.getBounds());
		}
	}
}

function updateAllCollidersList() {
	collidersCheckList = [
		obstacleCollidersList,
		leftToRightCollidersList,
		rightToLeftCollidersList,
		topToBottomCollidersList,
		bottomToTopCollidersList,
	];
}

// Controls functions :

function setControls() {
	document.getElementById('Attack').addEventListener('click', () => {
		loadSmallAttackTexture();
	});
	document.getElementById('Attack2').addEventListener('click', () => {
		loadBigAttackTexture();
	});
	document.getElementById('Idle').addEventListener('click', () => {
		loadIdleTexture();
	});
	document.getElementById('Jump').addEventListener('click', () => {
		loadJumpTexture();
	});
	document.getElementById('Die').addEventListener('click', () => {
		loadDieTexture();
	});
	document.getElementById('Run').addEventListener('click', () => {
		loadRunTexture();
	});
}

function setKeyboardControls() {
	window.addEventListener('keydown', (e) => {
		switch (e.key) {
			case 'ArrowDown':
				crouch();
				break;
			case 'ArrowUp':
				clearInterval(vxTimer);
				jump();
				break;
			case 'ArrowLeft':
				warrior.scale.x = -2;
				direction = -1;
				clearInterval(vxTimer);
				move();
				break;
			case 'ArrowRight':
				warrior.scale.x = 2;
				direction = 1;
				clearInterval(vxTimer);
				move();
				break;
			case 'é':
				takePotion();
				break;
			case 'a':
				smallAttack();
				break;
			case 'z':
				bigAttack();
				break;
			case 'e':
				activateObjectAround();
				break;
			case 'x':
				if (displayingText &amp;&amp; !displayingWarningText) {
					nextContent();
				}
				break;
			default:
				return;
		}
		if (e.key !== 'x' &amp;&amp; displayingText &amp;&amp; !displayingWarningText) {
			displayWarningMsg();
		}
	});

	window.addEventListener('keyup', (e) => {
		switch (e.key) {
			case 'a':
			case 'z':
				stopAttackingAnim();
				break;
			case 'ArrowUp':
				return;
			case 'ArrowRight':
			case 'ArrowLeft':
			default:
				stop();
		}
	});
}

// Move functions :

function move() {
	if (detectSpriteCollision(bottomCollisionBox, collidersCheckList)) {
		playSound(
			walkSound,
			GAME_SETTINGS.VOLUME_SETTINGS.WALKING_SOUND_VOLUME
		);
		animationState = animationStateEnum.RUNNING;
	}
	vx = GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MAX_SPEED;
}

function jump() {
	if (!detectSpriteCollision(bottomCollisionBox, collidersCheckList)) {
		return;
	} else {
		playingSound = false;
		playSound(
			warriorJumpSound,
			GAME_SETTINGS.VOLUME_SETTINGS.JUMPING_SOUND_VOLUME
		);
		animationState = animationStateEnum.JUMPING;
		vy = GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_JUMP_SPEED;
		warrior.y += vy;
		isJumping = true;
	}
}

function smallAttack() {
	playSound(
		attackSound,
		GAME_SETTINGS.VOLUME_SETTINGS.ATTACKING_SOUND_VOLUME
	);
	animationState = animationStateEnum.ATTACKING_ONE;
}

function bigAttack() {
	playSound(
		attackSound,
		GAME_SETTINGS.VOLUME_SETTINGS.ATTACKING_SOUND_VOLUME
	);
	animationState = animationStateEnum.ATTACKING_TWO;
}

function crouch() {
	animationState = animationStateEnum.CROUCHING;
}

function takePotion() {
	loadTakePotionTexture();
}

function stop() {
	playingSound = false;
	vxTimer = setInterval(() => {
		if (
			vx > GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED &amp;&amp;
			detectSpriteCollision(bottomCollisionBox, collidersCheckList)
		) {
			vx--;
		}
		if (vx === GAME_SETTINGS.PHYSICS_SETTINGS.PLAYER_MIN_SPEED) {
			animationState = animationStateEnum.IDLING;
			clearInterval(vxTimer);
		}
	}, 100);
	stopSound();
}
function stopAttackingAnim() {
	const timer = setTimeout(() => {
		animationState = animationStateEnum.IDLING;
		clearTimeout(timer);
	}, 500);
}

// Interactive functions:

function activateObjectAround() {
	const objectIndex = getObjectAround(warriorBounds);
	switch (objectIndex) {
		case 0:
			if (!treasureChestOpened1) {
				openTreasureChest(objectIndex);
			} else {
				closeTreasureChest(objectIndex);
			}
			treasureChestOpened1 = !treasureChestOpened1;
			break;
		case 1:
			if (!treasureChestOpened2) {
				openTreasureChest(objectIndex);
			} else {
				closeTreasureChest(objectIndex);
			}
			treasureChestOpened2 = !treasureChestOpened2;
			break;
		case 2:
			if (!treasureChestOpened3) {
				openTreasureChest(objectIndex);
			} else {
				closeTreasureChest(objectIndex);
			}
			treasureChestOpened3 = !treasureChestOpened3;
			break;

		default:
			return;
	}
}

function openTreasureChest(i) {
	displayDynamicMsg();
	playSound(
		openingTreasureChestSound,
		GAME_SETTINGS.VOLUME_SETTINGS.TREASURE_CHEST_SOUND_VOLUME
	);
	loadOpeningTreasureChestTexture(i);
	setTimeout(loadOpenedTreasureChestTexture(i), 400);
}

function closeTreasureChest(i) {
	playSound(
		openingTreasureChestSound,
		GAME_SETTINGS.VOLUME_SETTINGS.TREASURE_CHEST_SOUND_VOLUME
	);
	loadClosingTreasureChestTexture(i);
	setTimeout(loadClosedTreasureChestTexture(i), 400);
}

// Physics functions:

function reloadIfFalling() {
	if (warrior.y > app.screen.height) {
		window.location.reload();
	}
}

function calculateWideBoxes() {
	warriorBounds = warrior.getBounds();
	bottomCollisionBox.x = warriorBounds.x + (1 / 3) * warriorBounds.width;
	bottomCollisionBox.width = (1 / 3) * warriorBounds.width;
	bottomCollisionBox.y = warriorBounds.y + (4 / 5) * warriorBounds.height;
	bottomCollisionBox.height = (1 / 5) * warriorBounds.height + 1;
	topCollisionBox.x = warriorBounds.x + (1 / 3) * warriorBounds.width;
	topCollisionBox.width = (1 / 3) * warriorBounds.width;
	topCollisionBox.y = warriorBounds.y;
	topCollisionBox.height = (1 / 5) * warriorBounds.height + 1;
	leftCollisionBox.x = warriorBounds.x + 10;
	leftCollisionBox.width = warriorBounds.width / 3 - 10;
	leftCollisionBox.y = warriorBounds.y - 1;
	leftCollisionBox.height = (4 / 5) * warriorBounds.height;
	rightCollisionBox.x = warriorBounds.x + (2 * warriorBounds.width) / 3;
	rightCollisionBox.width = warriorBounds.width / 3 - 10;
	rightCollisionBox.y = warriorBounds.y - 1;
	rightCollisionBox.height = (4 / 5) * warriorBounds.height;
}

function updateWarriorCollider() {
	leftEdgeScreenReached = warrior.x &lt;= updatedLeftEdgeScreen;
	rightEdgeScreenReached =
		warrior.x + warrior.width >= updatedRightEdgeScreen;
	isAboutToCollideWithBottom = detectSpriteCollision(
		bottomCollisionBox,
		collidersCheckList
	);
	isAboutToCollideWithTop = detectSpriteCollision(
		topCollisionBox,
		collidersCheckList
	);
	isAboutToCollideWithLeft = detectSpriteCollision(
		leftCollisionBox,
		collidersCheckList
	);
	isAboutToCollideWithRight = detectSpriteCollision(
		rightCollisionBox,
		collidersCheckList
	);
}

function isColliding(playerBox, collider) {
	return (
		playerBox.x + playerBox.width > collider.x &amp;&amp;
		playerBox.x &lt; collider.x + collider.width &amp;&amp;
		playerBox.y + playerBox.height > collider.y &amp;&amp;
		playerBox.y &lt; collider.y + collider.height
	);
}

function detectSpriteCollision(playerBox, collidersCheckList) {
	for (const collidersSubCheckList of collidersCheckList) {
		for (const collider of collidersSubCheckList) {
			if (isColliding(playerBox, collider)) {
				return true;
			}
		}
	}
	return false;
}

function getObjectAround(playerBox) {
	for (let i = 0; i &lt; objectCollidersList.length; i++) {
		if (isColliding(playerBox, objectCollidersList[i])) {
			return i;
		}
	}
	return null;
}

function getMobileColliderUnderWarrior(playerBox, mobileCollidersCheckList) {
	for (let i = 0; i &lt; mobileCollidersCheckList.length; i++) {
		for (const subMobileColliderList of mobileCollidersCheckList[i]) {
			if (isColliding(playerBox, subMobileColliderList)) {
				return i;
			}
		}
	}
}

function updatingVx() {
	if (
		((isAboutToCollideWithRight || rightEdgeScreenReached) &amp;&amp;
			direction === 1) ||
		((isAboutToCollideWithLeft || leftEdgeScreenReached) &amp;&amp;
			direction === -1) ||
		displayingText
	) {
		return;
	}
	warrior.x += vx * direction;
}

function updatingVy() {
	if (!isAboutToCollideWithBottom) {
		applyingGravity();
		warrior.y += vy;
	}
}

function applyingGravity() {
	if (vy &lt; GAME_SETTINGS.PHYSICS_SETTINGS.GRAVITY) {
		vy++;
	}
}

//Audio functions:

function setBackgroundVolume() {
	const backgroundAudio = document.getElementById('audio');
	backgroundAudio.volume =
		GAME_SETTINGS.VOLUME_SETTINGS.BACKGROUND_SOUND_VOLUME;
}

function playSound(sound, volume) {
	if (!playingSound) {
		if (sound.currentTime !== 0) {
			sound.currentTime = 0;
		}
		if (sound.currentTime !== 0 &amp;&amp; sound.volume !== volume) {
			sound.volume = volume;
		}
		sound.play();
		playingSound = true;
	}
}

function stopSound() {
	attackSound.pause();
	walkSound.pause();
	if (isJumping === false) warriorJumpSound.pause();
}

function setAudioEvents() {
	attackSound.addEventListener('ended', () => {
		playingSound = false;
	});
	walkSound.addEventListener('ended', () => {
		playingSound = false;
	});
	warriorJumpSound.addEventListener('ended', () => {
		playingSound = false;
	});
}

// TextureLoader functions :

function updateAnimationState() {
	if (
		!isJumping &amp;&amp;
		isAboutToCollideWithBottom &amp;&amp;
		animationState === animationStateEnum.JUMPING
	) {
		animationState =
			vx > 0 ? animationStateEnum.RUNNING : animationStateEnum.IDLING;
	}
}

function loadWarriorAnimation() {
	switch (animationState) {
		case animationStateEnum.JUMPING:
			loadJumpTexture();
			break;
		case animationStateEnum.RUNNING:
			loadRunTexture();
			break;
		case animationStateEnum.CROUCHING:
			loadCrouchTexture();
			break;
		case animationStateEnum.ATTACKING_ONE:
			loadSmallAttackTexture();
			break;
		case animationStateEnum.ATTACKING_TWO:
			loadBigAttackTexture();
			break;
		case animationState.TAKING_POTION:
			loadTakePotionTexture();
			break;
		case animationStateEnum.IDLING:
		default:
			loadIdleTexture();
			break;
	}
}

function animateElements(delta) {
	animateWarrior(delta);
	animateTreasureChest(delta);
}

function animateWarrior(delta) {
	adventurerAnimationCount =
		Math.round(
			adventurerAnimationCount + getAnimationSpeed('player', delta)
		) % warriorTextureArray.length;
	warrior.texture = warriorTextureArray[adventurerAnimationCount];
}

function animateTreasureChest(delta) {
	treasureChestAnimationCount =
		Math.round(
			treasureChestAnimationCount + getAnimationSpeed('object', delta)
		) % treasureChest1TextureArray.length;
	treasureChest1.texture =
		treasureChest1TextureArray[treasureChestAnimationCount];
	treasureChest2.texture =
		treasureChest2TextureArray[treasureChestAnimationCount];
	treasureChest3.texture =
		treasureChest3TextureArray[treasureChestAnimationCount];
}

function getAnimationSpeed(animatedSpriteType, delta) {
	switch (animatedSpriteType) {
		case 'object':
			return (
				delta /
				GAME_SETTINGS.ANIMATION_SPEED_FACTORS
					.OBJECT_ANIMATION_SPEED_FACTOR
			);
		case 'player':
		default:
			return (
				delta /
				GAME_SETTINGS.ANIMATION_SPEED_FACTORS
					.PLAYER_ANIMATION_SPEED_FACTOR
			);
	}
}

function loadSmallAttackTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerAttacking1Anim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadBigAttackTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerAttacking2Anim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadIdleTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerIdlingAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadJumpTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerJumpingAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadRunTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerRunningAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadDieTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerDyingAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadCrouchTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerCrouchingAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadTakePotionTexture() {
	warriorTextureArray = [];
	let loaderArray = loaders.adventurerLoader.adventurerTakingPotionAnim;
	loaderArray.forEach((img) =>
		warriorTextureArray.push(new PIXI.Texture.from(img))
	);
}

function loadOpeningTreasureChestTexture(i) {
	let loaderArray = loaders.treasureChestLoader.treasureChestOpeningAnim;
	switch (i) {
		case 0:
			treasureChest1TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest1TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 1:
			treasureChest2TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest2TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 2:
			treasureChest3TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest3TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		default:
			return;
	}
}

function loadOpenedTreasureChestTexture(i) {
	let loaderArray = loaders.treasureChestLoader.treasureChestOpenedAnim;
	switch (i) {
		case 0:
			treasureChest1TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest1TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 1:
			treasureChest2TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest2TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 2:
			treasureChest3TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest3TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		default:
			return;
	}
}

function loadClosingTreasureChestTexture(i) {
	let loaderArray = loaders.treasureChestLoader.treasureChestOpeningAnim;
	loaderArray.reverse();
	switch (i) {
		case 0:
			treasureChest1TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest1TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 1:
			treasureChest2TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest2TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
		case 2:
			treasureChest3TextureArray = [];
			loaderArray.forEach((img) =>
				treasureChest3TextureArray.push(new PIXI.Texture.from(img))
			);
			break;
	}
}

function loadClosedTreasureChestTexture(i) {
	const treasureChestClosedLoader =
		loaders.treasureChestLoader.treasureChestClosed;
	switch (i) {
		case 0:
			treasureChest1TextureArray = [];
			treasureChest1TextureArray.push(
				new PIXI.Texture.from(treasureChestClosedLoader)
			);
			break;
		case 1:
			treasureChest2TextureArray = [];
			treasureChest2TextureArray.push(
				new PIXI.Texture.from(treasureChestClosedLoader)
			);
			break;
		case 2:
			treasureChest3TextureArray = [];
			treasureChest3TextureArray.push(
				new PIXI.Texture.from(treasureChestClosedLoader)
			);
			break;
		default:
			return;
	}
}

// Text related functions :

function manageTextContent(xCoordinate) {
	updateTextList(xCoordinate);
	updateTextDisplayZoneValue();
	displayTextInTextList();
}

function isWarriorInTextAera(xCoordinate, index) {
	const isWarriorInTextAreaBoolean =
		xCoordinate >
			textConfig.staticText[index].overlayConfig.activationArea.x1 &amp;&amp;
		xCoordinate &lt;
			textConfig.staticText[index].overlayConfig.activationArea.x2;
	return isWarriorInTextAreaBoolean;
}

function updateTextList(xCoordinate) {
	for (const textIndex in textConfig.staticText) {
		if (
			textListToShow.includes(
				textListToShow[textIndex] &amp;&amp;
					isWarriorInTextAera(xCoordinate, textIndex)
			)
		) {
			continue;
		} else if (
			isWarriorInTextAera(xCoordinate, textIndex) &amp;&amp;
			!textListToShow.includes(textConfig.staticText[textIndex])
		) {
			textListToShow.push(textConfig.staticText[textIndex]);
		} else if (
			!isWarriorInTextAera(xCoordinate, textIndex) &amp;&amp;
			textListToShow.includes(textConfig.staticText[textIndex])
		) {
			textListToShow.splice(textIndex, 1);
		}
	}
	if (textListToShow.length === 0) indexOfTextList = 0;
}

function hasBeenDisplayedInTextZone() {
	switch (textDisplayZone) {
		case textDisplayZoneEnum.ZONE_ONE:
			if (hasBeenDisplayedZone1) return true;
		case textDisplayZoneEnum.ZONE_TWO:
			if (hasBeenDisplayedZone2) return true;
		case textDisplayZoneEnum.ZONE_THREE:
			if (hasBeenDisplayedZone3) return true;
		case textDisplayZoneEnum.NO_ZONE:
		default:
			return false;
	}
}

function displayTextInTextList() {
	if (
		indexOfTextList !== textListToShow.length - 1 &amp;&amp;
		textListToShow.length !== 0 &amp;&amp;
		!displayingText &amp;&amp;
		!hasBeenDisplayedInTextZone() &amp;&amp;
		!isJumping
	) {
		buildTextBox(textListToShow[indexOfTextList]);
		displayingText = true;
	}
}

function nextContent() {
	playSound(
		openingTreasureChestSound,
		GAME_SETTINGS.VOLUME_SETTINGS.TREASURE_CHEST_SOUND_VOLUME
	);
	if (indexOfTextList &lt; textListToShow.length - 1) {
		removeTextContent();
		indexOfTextList++;
		buildTextBox(textListToShow[indexOfTextList]);
	} else {
		removeTextBox();
		displayingText = false;
		switch (textDisplayZone) {
			case textDisplayZoneEnum.ZONE_ONE:
				hasBeenDisplayedZone1 = true;
				break;
			case textDisplayZoneEnum.ZONE_TWO:
				hasBeenDisplayedZone2 = true;
				break;
			case textDisplayZoneEnum.ZONE_THREE:
				hasBeenDisplayedZone3 = true;
				break;
			case textDisplayZoneEnum.NO_ZONE:
			default:
				return;
		}
	}
}

function updateTextDisplayZoneValue() {
	if (
		warrior.x > GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_1.MIN_X &amp;&amp;
		warrior.x &lt; GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_1.MAX_X
	) {
		textDisplayZone = textDisplayZoneEnum.ZONE_ONE;
	} else if (
		warrior.x > GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_2.MIN_X &amp;&amp;
		warrior.x &lt; GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_2.MAX_X
	) {
		textDisplayZone = textDisplayZoneEnum.ZONE_TWO;
	} else if (
		warrior.x > GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_3.MIN_X &amp;&amp;
		warrior.x &lt; GAME_SETTINGS.TEXT_ZONES.TEXT_ZONE_3.MAX_X
	) {
		textDisplayZone = textDisplayZoneEnum.ZONE_THREE;
	} else {
		textDisplayZone = textDisplayZoneEnum.NO_ZONE;
	}
}

function buildTextBox(textConfig) {
	if (textConfig) {
		textBox = new PIXI.Container();
		buildTextBackgroundTexture(textConfig);
		buildText(textConfig);
		textBox.addChild(textBackGroundTexture, text);
		app.stage.addChild(textBox);
	}
}

function buildWarningTextBox(textConfig) {
	if (textConfig) {
		warningTextBox = new PIXI.Container();
		buildWarningTextBackgroundTexture(textConfig);
		buildWarningText(textConfig);
		if (textConfig.overlayConfig.nextButtonImg) {
			buildWarningNextTextButtonImg(textConfig);
		}
		warningNextTextButtonImg._destroyed
			? warningTextBox.addChild(warningTextBackGroundTexture, warningText)
			: warningTextBox.addChild(
					warningTextBackGroundTexture,
					warningText,
					warningNextTextButtonImg
			  );
		app.stage.addChild(warningTextBox);
	}
}

function buildTextBackgroundTexture(textConfig) {
	if (textBackGroundTexture._destroyed !== true) {
		textBackGroundTexture.destroy({
			children: true,
			texture: true,
			baseTexture: true,
		});
	}
	textBackGroundTexture = createBasicSprite(
		null,
		textBackGroundTexture,
		textConfig.overlayConfig.textBox
	);
}

function buildWarningTextBackgroundTexture(textConfig) {
	if (warningTextBackGroundTexture._destroyed !== true) {
		warningTextBackGroundTexture.destroy({
			children: false,
			texture: true,
			baseTexture: true,
		});
	}
	warningTextBackGroundTexture = createBasicSprite(
		null,
		warningTextBackGroundTexture,
		textConfig.overlayConfig.textBox
	);
}

function buildText(textConfig) {
	text = new PIXI.Text(
		textConfig.pixiRequirements.text,
		textConfig.pixiRequirements.style
	);
	text.x = textConfig.overlayConfig.text.x;
	text.y = textConfig.overlayConfig.text.y;
	text.anchor.set(textConfig.overlayConfig.text.anchor);
}

function buildWarningText(textConfig) {
	warningText = new PIXI.Text(
		textConfig.pixiRequirements.text,
		textConfig.pixiRequirements.style
	);
	warningText.x = textConfig.overlayConfig.text.x;
	warningText.y = textConfig.overlayConfig.text.y;
	warningText.anchor.set(textConfig.overlayConfig.text.anchor);
}

function buildWarningNextTextButtonImg(textConfig) {
	if (warningNextTextButtonImg._destroyed !== true) {
		warningNextTextButtonImg.destroy({
			children: false,
			texture: true,
			baseTexture: true,
		});
	}
	warningNextTextButtonImg = createBasicSprite(
		null,
		warningNextTextButtonImg,
		textConfig.overlayConfig.nextButtonImg
	);
}

function displayDynamicMsg() {
	removeTextContent();
	buildTextBox(textConfig.dynamicText.dynamicText1);
	const timer = setTimeout(() => {
		removeTextBox();
		clearTimeout(timer);
	}, 5000);
}

function displayWarningMsg() {
	displayingWarningText = true;
	buildWarningTextBox(textConfig.dynamicText.dynamicText2);
	const timer = setTimeout(() => {
		removeWarningTextBox();
		displayingWarningText = false;
		clearTimeout(timer);
	}, 2500);
}

function removeTextContent() {
	if (text._destroyed !== true) {
		text.destroy({children: true, texture: true, baseTexture: true});
	}
	text = new PIXI.Text();
}

function removeTextBox() {
	if (textBox._destroyed !== true) {
		textBox.destroy({children: false, texture: true, baseTexture: true});
	}
}

function removeWarningTextBox() {
	if (warningTextBox._destroyed !== true) {
		warningTextBox.destroy({
			children: false,
			texture: true,
			baseTexture: true,
		});
	}
}

// Camera functions :

function updateCameraCheckers() {
	isWarriorLeftCentered =
		warrior.x &lt;=
		updatedLeftEdgeScreen +
			GAME_SETTINGS.CAMERA_SETTINGS.LEFT_ACTIVATION_AREA_WIDTH;
	isWarriorRightCentered =
		warrior.x >=
		updatedRightEdgeScreen -
			GAME_SETTINGS.CAMERA_SETTINGS.RIGHT_ACTIVATION_AREA_WIDTH;
	leftEdgeStageReached = foreground.x >= app.stage.x;
	rightEdgeStageReached = foreground.x === -app.stage.width;
}

function moveCamera() {
	if (
		(leftEdgeStageReached &amp;&amp; direction === -1) ||
		(rightEdgeStageReached &amp;&amp; direction === 1)
	) {
		return;
	}
	if (
		(isWarriorRightCentered &amp;&amp; direction === 1) ||
		(isWarriorLeftCentered &amp;&amp; direction === -1)
	) {
		moveBackground();
		moveMiddleground();
		moveForeground();
		updateEdgeScreenValue();
		updateForegroundCollidersPosition();
	}
}

function moveBackground() {
	background.x -=
		vx * direction * GAME_SETTINGS.CAMERA_SETTINGS.BACKGROUND_SPEED_FACTOR;
}

function moveMiddleground() {
	middleground.x -=
		vx *
		direction *
		GAME_SETTINGS.CAMERA_SETTINGS.MIDDLEGROUND_SPEED_FACTOR;
}

function moveForeground() {
	foreground.x -= vx * direction;
}

function updateEdgeScreenValue() {
	updatedLeftEdgeScreen += vx * direction;
	updatedRightEdgeScreen += vx * direction;
}

function updateForegroundCollidersPosition() {
	const decorsColliderListLength = decorsCollidersList.length;
	const obstacleColliderListLength = obstacleCollidersList.length;
	const objectCollidersListLength = objectCollidersList.length;
	decorsCollidersList = [];
	obstacleCollidersList = [];
	objectCollidersList = [];
	leftToRightCollidersList = [];
	rightToLeftCollidersList = [];
	for (let i = 0; i &lt; decorsColliderListLength; i++) {
		decorsCollidersList.push(foreground.children[i].getBounds());
	}
	for (
		let i = decorsColliderListLength;
		i &lt; decorsColliderListLength + obstacleColliderListLength;
		i++
	) {
		obstacleCollidersList.push(foreground.children[i].getBounds());
	}
	for (
		let i = decorsColliderListLength + obstacleColliderListLength;
		i &lt;
		decorsColliderListLength +
			obstacleColliderListLength +
			objectCollidersListLength;
		i++
	) {
		objectCollidersList.push(foreground.children[i].getBounds());
	}
	updateMobileColliders();
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#adventurerAnimationCount">adventurerAnimationCount</a></li><li><a href="global.html#ANIMATION_SPEED_FACTORS">ANIMATION_SPEED_FACTORS</a></li><li><a href="global.html#animationState">animationState</a></li><li><a href="global.html#animationStateEnum">animationStateEnum</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#APP_SCREEN_SETTINGS">APP_SCREEN_SETTINGS</a></li><li><a href="global.html#attackSound">attackSound</a></li><li><a href="global.html#backdrops">backdrops</a></li><li><a href="global.html#background">background</a></li><li><a href="global.html#bottomCollisionBox">bottomCollisionBox</a></li><li><a href="global.html#bottomToTopCollidersList">bottomToTopCollidersList</a></li><li><a href="global.html#bottomToTopForegroundSubContainer">bottomToTopForegroundSubContainer</a></li><li><a href="global.html#CAMERA_SETTINGS">CAMERA_SETTINGS</a></li><li><a href="global.html#collidersCheckList">collidersCheckList</a></li><li><a href="global.html#connectLivereload">connectLivereload</a></li><li><a href="global.html#decorsColliders">decorsColliders</a></li><li><a href="global.html#decorsCollidersList">decorsCollidersList</a></li><li><a href="global.html#direction">direction</a></li><li><a href="global.html#dirUrl">dirUrl</a></li><li><a href="global.html#displayingText">displayingText</a></li><li><a href="global.html#displayingWarningText">displayingWarningText</a></li><li><a href="global.html#dynamicText">dynamicText</a></li><li><a href="global.html#elapsedTime">elapsedTime</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#foreground">foreground</a></li><li><a href="global.html#foregroundMobileCollidersSubContainer">foregroundMobileCollidersSubContainer</a></li><li><a href="global.html#foregroundStaticCollidersSubContainer">foregroundStaticCollidersSubContainer</a></li><li><a href="global.html#fpsDelta">fpsDelta</a></li><li><a href="global.html#hasBeenDisplayedZone1">hasBeenDisplayedZone1</a></li><li><a href="global.html#hasBeenDisplayedZone2">hasBeenDisplayedZone2</a></li><li><a href="global.html#hasBeenDisplayedZone3">hasBeenDisplayedZone3</a></li><li><a href="global.html#indexOfTextList">indexOfTextList</a></li><li><a href="global.html#isAboutToCollideWithBottom">isAboutToCollideWithBottom</a></li><li><a href="global.html#isAboutToCollideWithLeft">isAboutToCollideWithLeft</a></li><li><a href="global.html#isAboutToCollideWithRight">isAboutToCollideWithRight</a></li><li><a href="global.html#isAboutToCollideWithTop">isAboutToCollideWithTop</a></li><li><a href="global.html#isJumping">isJumping</a></li><li><a href="global.html#isWarriorLeftCentered">isWarriorLeftCentered</a></li><li><a href="global.html#isWarriorRightCentered">isWarriorRightCentered</a></li><li><a href="global.html#leftCollisionBox">leftCollisionBox</a></li><li><a href="global.html#leftEdgeScreenReached">leftEdgeScreenReached</a></li><li><a href="global.html#leftEdgeStageReached">leftEdgeStageReached</a></li><li><a href="global.html#leftToRightCollidersList">leftToRightCollidersList</a></li><li><a href="global.html#leftToRightForegroundSubContainer">leftToRightForegroundSubContainer</a></li><li><a href="global.html#livereload">livereload</a></li><li><a href="global.html#liveReloadServer">liveReloadServer</a></li><li><a href="global.html#loaders">loaders</a></li><li><a href="global.html#middleground">middleground</a></li><li><a href="global.html#movementCount">movementCount</a></li><li><a href="global.html#movementSpeed">movementSpeed</a></li><li><a href="global.html#objectColliders">objectColliders</a></li><li><a href="global.html#objectCollidersList">objectCollidersList</a></li><li><a href="global.html#obstacleColliders">obstacleColliders</a></li><li><a href="global.html#obstacleCollidersList">obstacleCollidersList</a></li><li><a href="global.html#openingTreasureChestSound">openingTreasureChestSound</a></li><li><a href="global.html#opn">opn</a></li><li><a href="global.html#pathDictionnary">pathDictionnary</a></li><li><a href="global.html#pathToAnimation">pathToAnimation</a></li><li><a href="global.html#pathToImgFolder">pathToImgFolder</a></li><li><a href="global.html#pathToNextTextIcon">pathToNextTextIcon</a></li><li><a href="global.html#PHYSICS_SETTINGS">PHYSICS_SETTINGS</a></li><li><a href="global.html#playingSound">playingSound</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#rightCollisionBox">rightCollisionBox</a></li><li><a href="global.html#rightEdgeScreenReached">rightEdgeScreenReached</a></li><li><a href="global.html#rightEdgeStageReached">rightEdgeStageReached</a></li><li><a href="global.html#rightToLeftCollidersList">rightToLeftCollidersList</a></li><li><a href="global.html#rightToLeftForegroundSubContainer">rightToLeftForegroundSubContainer</a></li><li><a href="global.html#staticText">staticText</a></li><li><a href="global.html#styleConfig">styleConfig</a></li><li><a href="global.html#text">text</a></li><li><a href="global.html#TEXT_ZONES">TEXT_ZONES</a></li><li><a href="global.html#textBackGroundTexture">textBackGroundTexture</a></li><li><a href="global.html#textBox">textBox</a></li><li><a href="global.html#textDisplayZone">textDisplayZone</a></li><li><a href="global.html#textDisplayZoneEnum">textDisplayZoneEnum</a></li><li><a href="global.html#textListToShow">textListToShow</a></li><li><a href="global.html#TICKER_SETTINGS">TICKER_SETTINGS</a></li><li><a href="global.html#topCollisionBox">topCollisionBox</a></li><li><a href="global.html#topToBottomCollidersList">topToBottomCollidersList</a></li><li><a href="global.html#topToBottomForegroundSubContainer">topToBottomForegroundSubContainer</a></li><li><a href="global.html#treasureChest1">treasureChest1</a></li><li><a href="global.html#treasureChest1TextureArray">treasureChest1TextureArray</a></li><li><a href="global.html#treasureChest2">treasureChest2</a></li><li><a href="global.html#treasureChest2TextureArray">treasureChest2TextureArray</a></li><li><a href="global.html#treasureChest3">treasureChest3</a></li><li><a href="global.html#treasureChest3TextureArray">treasureChest3TextureArray</a></li><li><a href="global.html#treasureChestAnimationCount">treasureChestAnimationCount</a></li><li><a href="global.html#treasureChestOpened1">treasureChestOpened1</a></li><li><a href="global.html#treasureChestOpened2">treasureChestOpened2</a></li><li><a href="global.html#treasureChestOpened3">treasureChestOpened3</a></li><li><a href="global.html#updatedLeftEdgeScreen">updatedLeftEdgeScreen</a></li><li><a href="global.html#updatedRightEdgeScreen">updatedRightEdgeScreen</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#VOLUME_SETTINGS">VOLUME_SETTINGS</a></li><li><a href="global.html#vx">vx</a></li><li><a href="global.html#vxTimer">vxTimer</a></li><li><a href="global.html#vy">vy</a></li><li><a href="global.html#walkSound">walkSound</a></li><li><a href="global.html#warningNextTextButtonImg">warningNextTextButtonImg</a></li><li><a href="global.html#warningText">warningText</a></li><li><a href="global.html#warningTextBackGroundTexture">warningTextBackGroundTexture</a></li><li><a href="global.html#warningTextBox">warningTextBox</a></li><li><a href="global.html#warrior">warrior</a></li><li><a href="global.html#warriorBounds">warriorBounds</a></li><li><a href="global.html#warriorColliders">warriorColliders</a></li><li><a href="global.html#warriorJumpSound">warriorJumpSound</a></li><li><a href="global.html#warriorTextureArray">warriorTextureArray</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Dec 11 2020 19:56:09 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
